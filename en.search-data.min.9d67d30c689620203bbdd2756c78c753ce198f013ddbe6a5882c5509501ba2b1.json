[{"id":0,"href":"/docs/first_one/","title":"About Me","section":"Hiüôã‚Äç‚ôÇÔ∏è","content":" Greetings! üëã # Introduction # Greetings, I\u0026rsquo;m Harpreet Singh, a Computer Science major at IIITH, finished my third semester. Having recently completed courses like CS3.301 (Operating Systems and Networks) and CS1.302 (Automata Theory), I find myself intrigued by the practical applications of Computer Science. Witnessing theories come to life in computer systems and algorithms has been truly captivating.\nWhat to Expect. # As someone with dynamic interests, my focus shifts based on current happenings. Primarily, my curiosity centers around the developments in the field of computer science. So this is a place where I would not only share algorithms and data structure problems but also research articles in the tech domain. Rest assured, these articles won\u0026rsquo;t be your typical run-of-the-mill reads‚Äîthey\u0026rsquo;re designed to captivate and inspire üòâ.\nRoad Ahead # It\u0026rsquo;s just the beginning, and I would keep updating my daily learnings, challenges, and discoveries regularly. I hope that, in turn, you find something new and interesting with each visit. I won\u0026rsquo;t fail the people who give their extremely valuable time and attention on this page!\nThank you for stopping by, see you on the first post!\n#StayCurious üöÄ\n"},{"id":1,"href":"/docs/lc/getsum/","title":"371. Sum of Two Integers","section":"Leetcode","content":" Leetcode 371 # Sum of Two Integers # Problem Statement:\nGiven two integers a and b, return the sum of the two integers without using the operators + and -.\nLogic # We would be treating a and b in binary form for understanding bit operations. First bit of sum calculated by xor(0^1, 1^0, 0^0, 1^1), but for the addition such as 1+1 = 10 we must have some carry, which can be found by \u0026amp; operator between the two numbers. Also note that this approach takes count into the 3 bit addition in case of carry (1^1^1=1 and 1\u0026amp;1\u0026amp;1 = 1).\nWe proceed as follows\nprocedure ADD(a, b): if a: carry = a AND b sum = a XOR b return ADD(carry \u0026lt;\u0026lt; 1, sum) else: return sum Code # class Solution { // Working c++ code public: int getSum(int a, int b) { if (a) return getSum((a \u0026amp; b) \u0026lt;\u0026lt; 1, a ^ b); return b; } }; Time Complexity # O(log(max(a, b))) where \u0026ldquo;log\u0026rdquo; is the logarithm base 2. This is because in each recursive call, the size of the input (represented by the maximum of \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo;) is reduced by half due to the left shift (carry \u0026laquo; 1).\nSpace Complexity # O(log(max(a,b))) This is because each recursive call consumes space on the call stack, and the maximum depth of the recursion is determined by the number of bits needed to represent the larger of the two numbers, \u0026lsquo;a\u0026rsquo; or \u0026lsquo;b\u0026rsquo;.\n"},{"id":2,"href":"/docs/lc/8/","title":"8. String to Integer","section":"Leetcode","content":" 8. String to Integer # Problem Statement # Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++\u0026#39;s atoi function). The algorithm for myAtoi(string s) is as follows: Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is \u0026#39;-\u0026#39; or \u0026#39;+\u0026#39;. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. Convert these digits into an integer (i.e. \u0026#34;123\u0026#34; -\u0026gt; 123, \u0026#34;0032\u0026#34; -\u0026gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1. Return the integer as the final result. Note: Only the space character \u0026#39; \u0026#39; is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. Approach # Let\u0026rsquo;s break the problem into simple pieces and try to handle each piece.\nInitial Processing # Skip leading whitespaces. Identify the sign (positive or negative). Handle leading + or - only once, as any subsequent symbols are considered extraneous. Overflow Prevention # Implement a check for potential overflow: If n exceeds INT_MAX/10, it would lead to overflow. If n equals INT_MAX/10, additional digits are allowed only up to 7 to avoid overflow. Iterative Parsing # Iterate through the input until a non-digit character is encountered. Code: # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a = 1e9+7; class Solution { public: int myAtoi(string s) { int i= 0; while(s[i]==32) i+=1; int sign = 1; if(s[i]==\u0026#39;-\u0026#39;){ sign *= -1;i+=1;} else if(s[i]==\u0026#39;+\u0026#39;)i+=1; int num = 0; while(i\u0026lt;s.size() and isdigit(s[i])){ if(num\u0026gt;INT_MAX/10 or (num==INT_MAX/10 and (s[i]-\u0026#39;0\u0026#39;)\u0026gt;7)) return sign==1?INT_MAX:INT_MIN; else{ num = num*10+(s[i]-\u0026#39;0\u0026#39;); } i+=1; } return num*sign; } }; Time Complexity # O(n)- where n is the length of the input string s.\nSpace Complexity # O(1)- constant space, as only the variables are used and don\u0026rsquo;t scale to the size of the input.\nThanks! Have a nice day!!üòâ\n"},{"id":3,"href":"/docs/misc/minflips/","title":"Minimum flips to make xy string","section":"Miscellaneous Problems","content":" 1. Minimum flips to make xy string # Problem Statement # You are given a string consisting of the letters x and y, such as xyxxxyxyy. In addition, you have an operation called flip, which changes a single x to y or vice versa. Determine how many times you would need to apply this operation to ensure that all x\u0026rsquo;s come before all y\u0026rsquo;s. In the preceding example, it suffices to flip the second and sixth characters, so you should return 2. Before reading further, I recommend to try it on your own!\nApproach # Two Pass # A simple yet a beautiful way is for each element, find the number of y\u0026rsquo;s on the left in one pass and number of x\u0026rsquo;s on the next half. For a valid element, all elements on it\u0026rsquo;s left are converted to x and vice versa, all elements on the right are converted to y. We look out for element for which sum of both(aka our cost) is minimum.\nCode # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; void solve(){ vector\u0026lt;int\u0026gt; cst(s.size(), 0); for(int i=1 ; i\u0026lt; s.size(); i++){ if(s[i-1]==\u0026#39;y\u0026#39;) cst[i]=1+cst[i-1]; else cst[i]=cst[i-1]; } vector\u0026lt;int\u0026gt; cstx(s.size(), 0); for(int i=s.size()-2 ;i\u0026gt;=0; i--){ if(s[i+1]==\u0026#39;x\u0026#39;) cstx[i]=1+cstx[i+1]; else cstx[i]=cstx[i+1]; } // Combine two vectors using transform vector\u0026lt;int\u0026gt; combined(s.size()); transform(cst.begin(), cst.end(), cstx.begin(), combined.begin(), plus\u0026lt;int\u0026gt;()); auto it = min_element(combined.begin(), combined.end()); int res = *it; cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } int a = 1e9+7; int main(){ cin\u0026gt;\u0026gt;s; solve(); } Time Complexity # O(n): Only 2 pass are needed.\nSpace Complexity # O(n) : Extra space used by cst and cstx and combined(completely not needed, just tried STL feature).\nDP # Let x = 0 and y = 1. We can use a dp where dp[i][j] denotes ith index with letter j.\nAnd return the minimum of dp[n-1][0]and dp[n-1][1].\nCode # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; void solve() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.size(), vector\u0026lt;int\u0026gt;(2)); dp[0][0] = (s[0]==\u0026#39;x\u0026#39;?0:1); dp[0][1] = (s[0]==\u0026#39;y\u0026#39;?0:1); for (int i = 1; i \u0026lt; s.size(); ++i) { // all previous should be x and this one should also be x dp[i][0] = dp[i-1][0] + (s[i]==\u0026#39;y\u0026#39;?1:0); // either start y from this point or start y from the begining dp[i][1] = min(dp[i-1][0], dp[i-1][1])+(s[i]==\u0026#39;x\u0026#39;?1:0); } cout\u0026lt;\u0026lt; min(dp[s.size()-1][0], dp[s.size()-1][1])\u0026lt;\u0026lt;endl; } int a = 1e9+7; int main(){ cin\u0026gt;\u0026gt;s; solve(); } Time Complexity # O(n): As we only need to iterate through string once.\nSpace Complexity # O(2*n) : Extra space used by dp.\n"},{"id":4,"href":"/docs/wa/rating_system/","title":"Rating Algorithm in chess","section":"Weekly Algorithm","content":" Chess rating system # Introduction # A chess rating system is a system used in chess to estimate the strength of a player, based on their performance versus other players. They are used by organisations like FIDE, English Chess Federation and online chess websites like chess.com, Lichess only to name a few. In general for a player, their strength is determined by the rating, higher rating indicates more proficiency.\nWinning against higher-rated players boosts one\u0026rsquo;s rating, while losing to lower-rated players leads to a decrease. But how exactly do we give the rating as in attempt to consolidate all the factors into a single number, we are likely to miss some aspects. We therefore try to make it as fair as it should. That\u0026rsquo;s why the most commonly used rating is the Elo rating system invented by Arpad Elo. USCF uses USCF system in which K factor is varies for each match and player is given bonus points for the superior performance in the tournament. So let\u0026rsquo;s first understand what is the Elo rating system in an easy way.\nThe Elo Rating System # Simple Example # First we need to know what is the expected score and what is an actual score of the player in a match. For instance, a player1 of rating 1200 plays 16 matches and wins 10 , and draws 1,against player2 with rating 1000, his actual score is 10.5(1 for each win, 0.5 for each draw, 0 for a loss :/), however expected score is calculated through the probability of the winning which is $$P1 = \\frac{1.0}{1.0 + 10^{\\frac{{\\text{{rating1}} - \\text{{rating2}}}}{400}}}$$ Rating difference of gave player1 expected score of 0.75. This is an impossible score and a draw would be costly conversely a draw would improve the rating of player2. The formula is\n$$ \\begin{align*} NewRating \u0026amp;= OldRating + K \\cdot (actual - expected) \\tag{i} \\ \\end{align*} $$\nwhere $K$=10\nLinear Approximation # Elo devised a linear approximation to his full system, negating the need to calculate expected score. So we have\n$$ R_{\\text{new}} = R_{\\text{old}} + \\frac{K(W_L)}{2} - \\frac{K}{4C} \\sum_{i} D_i $$\nWhere $R_{\\text{new}}$ and $R_{\\text{old}}$ are new and old ratings respectively, $D_i$ is the difference of opponents\u0026rsquo; rating minus the player\u0026rsquo;s rating, $W$ is the number of wins, and $L$ is the number of losses, $C=200$, and $K=32$. The term $\\frac{W-L}{2}$ is the score above or below 0, and $\\frac{\\sum D}{4C}$ is the expected score according to: 4C rating points equals 100%. Note that this of the similar form as $(i)$.\nThe USCF used a modification of this system to calculate ratings after individual games of correspondence chess(it is usually played through a correspondence chess server, a public internet chess forum, or email, in contrast to over the board chess) with a $K$ = 32 and $C$ = 200.\nCode # Note that this C++ code only implements the equation $(i)$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; float Probability(int rating1, int rating2) { return 1.0 * 1.0/(1+ 1.0* pow(10,1.0 * (rating1 - rating2) / 400)); } void EloRating(float Ra, float Rb, int K, int d) { // To calculate the Winning Probabilities float Pb = Probability(Ra, Rb); float Pa = Probability(Rb, Ra); // Case When Player A wins if (d == 1) { Ra = Ra + K * (1 - Pa); Rb = Rb + K * (0 - Pb); } // Case When Player B wins else if(d==0){ Ra = Ra + K * (0 - Pa); Rb = Rb + K * (1 - Pb); } // Case of draw else if (d==0.5){ Ra = Ra + K * (0.5- Pa); Rb = Rb + K * (0.5 - Pb); } cout \u0026lt;\u0026lt; \u0026#34;Updated Ratings:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Ra = \u0026#34; \u0026lt;\u0026lt; Ra \u0026lt;\u0026lt; \u0026#34; Rb = \u0026#34; \u0026lt;\u0026lt; Rb\u0026lt;\u0026lt;endl; } int main() { float Ra , Rb; cout \u0026lt;\u0026lt; \u0026#34;Enter Ra and Rb: \u0026#34;; if (!(cin \u0026gt;\u0026gt; Ra \u0026gt;\u0026gt; Rb) || !is_floating_point\u0026lt;decltype(Ra)\u0026gt;::value || !is_floating_point\u0026lt;decltype(Rb)\u0026gt;::value) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: Ra and Rb must be floats.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } int K = 10; int d; cout\u0026lt;\u0026lt;\u0026#34;Enter the result\u0026#34;\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;d; EloRating(Ra, Rb, K, d); cout\u0026lt;\u0026lt;endl; return 0; } Credits: Wikipedia, GFG, Medium\nThanks for reading!ü§ì\n"}]